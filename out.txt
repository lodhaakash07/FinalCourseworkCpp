#ifndef CSVHANDLER_H
#define CSVHANDLER_H

#include "Matrix.h"
#include "FileHandler.h"
#include <vector>
#include <string>

class CSVHandler : public FileHandler {
public:
    Matrix readCSV(const std::string& filename);
};

#endif // CSVHANDLER_H#ifndef FILEHANDLER_H
#define FILEHANDLER_H

#include <vector>
#include <string>

class FileHandler {
public:
    std::vector<std::string> readFile(const std::string& filename);
};

#endif // FILEHANDLER_H#include "Headers/CSVHandler.h"
#include <sstream>


Matrix CSVHandler::readCSV(const std::string& filename) {
    std::vector<std::string> lines = readFile(filename);
    Matrix data;

    for (const std::string& line : lines) {
        std::vector<double> row;
        std::stringstream ss(line);
        std::string cell;

        while (std::getline(ss, cell, ',')) {
            row.push_back(std::stod(cell));
        }

        data.appendRow(row);
    }
    return data;
}#include "Headers/FileHandler.h""
#include <fstream>
#include <iostream>

std::vector<std::string> FileHandler::readFile(const std::string& filename) {
    std::vector<std::string> lines;
    std::ifstream file(filename);

    if (!file.is_open()) {
        std::cout << "Failed to open the file: " << filename << std::endl;
        return lines;
    }

    std::string line;
    while (std::getline(file, line)) {
        lines.push_back(line);
    }

    file.close();
    return lines;
}#include <iostream>
#include <vector>
#include "Headers/Matrix.h"
#include "Headers/CSVHandler.h"

#include "Headers/Window.h"
#include <iostream>
#include <vector>
#include "Headers/Portfolio.h"

int main() {
    // Read the file
    CSVHandler csvHandler;
    Matrix assetReturns = csvHandler.readCSV("Data/asset_returns.csv");

    // Check if matrix is empty
    if (assetReturns.empty()) {
        std::cout << "Matrix is empty" << std::endl;
        return 0;
    }

    // Create an object of Window
    Window window(100, 10);

    // Create an array of Portfolios
    std::vector<Portfolio> portfolios;

    // Loop over assetReturns to create rolling window portfolios
    int numAssets = assetReturns.front().size();
    std::cout << "Number of assets: " << numAssets << std::endl;

    int count = 0;
    for (int currentIndex = 0; currentIndex + window.getInSampleSize() < assetReturns.size(); currentIndex += window.getOutSampleSize()) {

        std::cout << "Processing in-sample rolling window: " << count++ << std::endl;
        Portfolio portfolio(assetReturns);
        portfolio.addAssetReturnsIndex(currentIndex, currentIndex + window.getInSampleSize());

        // Calculate mean returns and covariance matrix
        portfolio.calculateMeanReturns();
        portfolio.calculateCovarianceMatrix();

        portfolios.push_back(portfolio);
    }

    std::cout << "Success" << std::endl;

    return 0;
}#ifndef MATRIX_H
#define MATRIX_H

#include <vector>

class Matrix : public std::vector<std::vector<double> > {
public:
    

    void appendRow(const std::vector<double>& row);
    Matrix subset(int startIndex, int endIndex) const;
   // Matrix transpose() const;
    Matrix operator*(const Matrix& other) const;
    Matrix operator/(double scalar) const;
};

#endif // MATRIX_H#include "Headers/Matrix.h""
#include <stdexcept>


void Matrix::appendRow(const std::vector<double>& row) {
    if (!empty() && row.size() != front().size()) {
        throw std::runtime_error("Cannot append row: Incompatible size");
    }
    push_back(row);
}

Matrix Matrix::subset(int startIndex, int endIndex) const {
    if (startIndex < 0 || endIndex >= size() || startIndex > endIndex) {
        throw std::runtime_error("Invalid indices for subsetting");
    }

    Matrix subsetData;
    for (int i = startIndex; i < endIndex; ++i) {
        subsetData.push_back((*this)[i]);
    }

    return subsetData;
}
/*
Matrix Matrix::transpose() const {
    int numRows = size();
    int numCols = front().size();

    Matrix result(numCols, numRows);

    for (int i = 0; i < numRows; ++i) {
        for (int j = 0; j < numCols; ++j) {
            result[j][i] = (*this)[i][j];
        }
    }

    return result;
}



Matrix Matrix::operator*(const Matrix& other) const {
    // Check if the matrices are compatible for multiplication
    if (front().size() != other.size()) {
        throw std::runtime_error("Matrix multiplication error: Incompatible matrix dimensions");
    }

    int numRows = size();
    int numCols = other.front().size();
    int commonDim = front().size();

    Matrix result(numRows, std::vector<double>(numCols));

    for (int i = 0; i < numRows; ++i) {
        for (int j = 0; j < numCols; ++j) {
            double sum = 0.0;
            for (int k = 0; k < commonDim; ++k) {
                sum += (*this)[i][k] * other[k][j];
            }
            result[i][j] = sum;
        }
    }

    return result;
}

Matrix Matrix::operator/(double scalar) const {
    Matrix result(size(), std::vector<double>(front().size()));

    for (size_t i = 0; i < size(); ++i) {
        for (size_t j = 0; j < front().size(); ++j) {
            result[i][j] = (*this)[i][j] / scalar;
        }
    }

    return result;
} */#ifndef PORTFOLIO_H
#define PORTFOLIO_H

#include "Matrix.h"
#include <vector>

class Portfolio {
private:
    const Matrix& assetReturns;
    int assetReturnsIndexes[2];
    std::vector<double> meanReturns;
    Matrix covarianceMatrix;

public:
    Portfolio(const Matrix& assetReturns);

    void addAssetReturnsIndex(int start, int end);
    void calculateMeanReturns();
    void calculateCovarianceMatrix();

    std::vector<double> getMeanReturns();
    Matrix getCovarianceMatrix();
};

#endif // PORTFOLIO_H#ifndef WINDOW_H
#define WINDOW_H

class Window {
private:
    int inSampleSize;
    int outSampleSize;

public:
    Window();
    Window(int inSample, int outSample);

    void setInSampleSize(int inSample);
    void setOutSampleSize(int outSample);

    int getInSampleSize() const;
    int getOutSampleSize() const;
};

#endif // WINDOW_H#include "Headers/Portfolio.h"
#include "Headers/Matrix.h"
#include <iostream>

Portfolio::Portfolio(const Matrix& assetReturns) : assetReturns(assetReturns) {}


void Portfolio::addAssetReturnsIndex(int start, int end) {
    assetReturnsIndexes[0] = start;
    assetReturnsIndexes[1] = end;
}

void Portfolio::calculateMeanReturns() {
    const Matrix& assetData = assetReturns;

    int numAssets = assetData.front().size();
    int numDays = assetData.size();

    meanReturns.clear();
    meanReturns.reserve(numAssets);

    for (int i = 0; i < numAssets; ++i) {
        double sum = 0.0;
        for (int k = assetReturnsIndexes[0]; k < assetReturnsIndexes[1]; ++k) {
            sum += assetData[k][i];
        }
        double meanReturn = sum / (assetReturnsIndexes[1] - assetReturnsIndexes[0]);
        meanReturns.push_back(meanReturn);
    }
}

void Portfolio::calculateCovarianceMatrix() {
    const Matrix& assetData = assetReturns;

    int numAssets = assetData[0].size();
    int numDays = assetData.size();

    covarianceMatrix.clear();
    covarianceMatrix.resize(numAssets, std::vector<double>(numAssets));

    for (int i = 0; i < numAssets; ++i) {
        for (int j = 0; j <= i; ++j) {
            double sum = 0.0;
            for (int k = assetReturnsIndexes[0]; k < assetReturnsIndexes[1]; ++k) {
                double diff_i = assetData[k][i] - meanReturns[i];
                double diff_j = assetData[k][j] - meanReturns[j];
                sum += diff_i * diff_j;
            }
            double cov = sum / (assetReturnsIndexes[1] - assetReturnsIndexes[0] - 1);
            covarianceMatrix[i][j] = cov;
            covarianceMatrix[j][i] = cov; // Covariance matrix is symmetric
        }
    }
}std::vector<double> Portfolio::getMeanReturns() {
    if (meanReturns.empty()) {
        calculateMeanReturns();
    }
    return meanReturns
    
    ;
}

Matrix Portfolio::getCovarianceMatrix() {
    if (covarianceMatrix.empty()) {
        calculateCovarianceMatrix();
    }
    return covarianceMatrix;
}#include "Headers/Window.h"

Window::Window() : inSampleSize(0), outSampleSize(0) {}

Window::Window(int inSample, int outSample) : inSampleSize(inSample), outSampleSize(outSample) {}

void Window::setInSampleSize(int inSample) {
    inSampleSize = inSample;
}

void Window::setOutSampleSize(int outSample) {
    outSampleSize = outSample;
}

int Window::getInSampleSize() const {
    return inSampleSize;
}

int Window::getOutSampleSize() const {
    return outSampleSize;
}